// This file is @generated by syn-serde-internal-codegen
// (generate function at tools/codegen/src/convert.rs).
// It is not intended for manual editing.

#![cfg_attr(rustfmt, rustfmt::skip)]
#![allow(unused_parens)]
#![allow(
    clippy::double_parens,
    clippy::just_underscores_and_digits,
    clippy::match_single_binding,
)]
use crate::*;
syn_trait_impl!(syn::Abi);
impl From<&syn::Abi> for Abi {
    fn from(node: &syn::Abi) -> Self {
        Self { name: node.name.map_into() }
    }
}
impl From<&Abi> for syn::Abi {
    fn from(node: &Abi) -> Self {
        Self {
            extern_token: default(),
            name: node.name.map_into(),
        }
    }
}
syn_trait_impl!(syn::AngleBracketedGenericArguments);
impl From<&syn::AngleBracketedGenericArguments> for AngleBracketedGenericArguments {
    fn from(node: &syn::AngleBracketedGenericArguments) -> Self {
        Self {
            colon2_token: node.colon2_token.is_some(),
            args: node.args.map_into(),
        }
    }
}
impl From<&AngleBracketedGenericArguments> for syn::AngleBracketedGenericArguments {
    fn from(node: &AngleBracketedGenericArguments) -> Self {
        Self {
            colon2_token: default_or_none(node.colon2_token),
            lt_token: default(),
            args: node.args.map_into(),
            gt_token: default(),
        }
    }
}
syn_trait_impl!(syn::AssocConst);
impl From<&syn::AssocConst> for AssocConst {
    fn from(node: &syn::AssocConst) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            value: node.value.ref_into(),
        }
    }
}
impl From<&AssocConst> for syn::AssocConst {
    fn from(node: &AssocConst) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            eq_token: default(),
            value: node.value.ref_into(),
        }
    }
}
syn_trait_impl!(syn::AssocType);
impl From<&syn::AssocType> for AssocType {
    fn from(node: &syn::AssocType) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            ty: node.ty.ref_into(),
        }
    }
}
impl From<&AssocType> for syn::AssocType {
    fn from(node: &AssocType) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            eq_token: default(),
            ty: node.ty.ref_into(),
        }
    }
}
syn_trait_impl!(syn::AttrStyle);
impl From<&syn::AttrStyle> for AttrStyle {
    fn from(node: &syn::AttrStyle) -> Self {
        match node {
            syn::AttrStyle::Outer => AttrStyle::Outer,
            syn::AttrStyle::Inner(..) => AttrStyle::Inner,
        }
    }
}
impl From<&AttrStyle> for syn::AttrStyle {
    fn from(node: &AttrStyle) -> Self {
        match node {
            AttrStyle::Outer => syn::AttrStyle::Outer,
            AttrStyle::Inner => syn::AttrStyle::Inner(default()),
        }
    }
}
syn_trait_impl!(syn::Attribute);
impl From<&syn::Attribute> for Attribute {
    fn from(node: &syn::Attribute) -> Self {
        Self {
            style: node.style.ref_into(),
            meta: node.meta.ref_into(),
        }
    }
}
impl From<&Attribute> for syn::Attribute {
    fn from(node: &Attribute) -> Self {
        Self {
            pound_token: default(),
            style: node.style.ref_into(),
            bracket_token: default(),
            meta: node.meta.ref_into(),
        }
    }
}
syn_trait_impl!(syn::BareFnArg);
impl From<&syn::BareFnArg> for BareFnArg {
    fn from(node: &syn::BareFnArg) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            name: node.name.ref_map(|(_0, _1)| (*_0).ref_into()),
            ty: node.ty.ref_into(),
        }
    }
}
impl From<&BareFnArg> for syn::BareFnArg {
    fn from(node: &BareFnArg) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            name: node.name.ref_map(|_0| ((*_0).ref_into(), default())),
            ty: node.ty.ref_into(),
        }
    }
}
syn_trait_impl!(syn::BareVariadic);
impl From<&syn::BareVariadic> for BareVariadic {
    fn from(node: &syn::BareVariadic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            name: node.name.ref_map(|(_0, _1)| (*_0).ref_into()),
            comma: node.comma.is_some(),
        }
    }
}
impl From<&BareVariadic> for syn::BareVariadic {
    fn from(node: &BareVariadic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            name: node.name.ref_map(|_0| ((*_0).ref_into(), default())),
            dots: default(),
            comma: default_or_none(node.comma),
        }
    }
}
syn_trait_impl!(syn::BinOp);
impl From<&syn::BinOp> for BinOp {
    fn from(node: &syn::BinOp) -> Self {
        match node {
            syn::BinOp::Add(..) => BinOp::Add,
            syn::BinOp::Sub(..) => BinOp::Sub,
            syn::BinOp::Mul(..) => BinOp::Mul,
            syn::BinOp::Div(..) => BinOp::Div,
            syn::BinOp::Rem(..) => BinOp::Rem,
            syn::BinOp::And(..) => BinOp::And,
            syn::BinOp::Or(..) => BinOp::Or,
            syn::BinOp::BitXor(..) => BinOp::BitXor,
            syn::BinOp::BitAnd(..) => BinOp::BitAnd,
            syn::BinOp::BitOr(..) => BinOp::BitOr,
            syn::BinOp::Shl(..) => BinOp::Shl,
            syn::BinOp::Shr(..) => BinOp::Shr,
            syn::BinOp::Eq(..) => BinOp::Eq,
            syn::BinOp::Lt(..) => BinOp::Lt,
            syn::BinOp::Le(..) => BinOp::Le,
            syn::BinOp::Ne(..) => BinOp::Ne,
            syn::BinOp::Ge(..) => BinOp::Ge,
            syn::BinOp::Gt(..) => BinOp::Gt,
            syn::BinOp::AddAssign(..) => BinOp::AddAssign,
            syn::BinOp::SubAssign(..) => BinOp::SubAssign,
            syn::BinOp::MulAssign(..) => BinOp::MulAssign,
            syn::BinOp::DivAssign(..) => BinOp::DivAssign,
            syn::BinOp::RemAssign(..) => BinOp::RemAssign,
            syn::BinOp::BitXorAssign(..) => BinOp::BitXorAssign,
            syn::BinOp::BitAndAssign(..) => BinOp::BitAndAssign,
            syn::BinOp::BitOrAssign(..) => BinOp::BitOrAssign,
            syn::BinOp::ShlAssign(..) => BinOp::ShlAssign,
            syn::BinOp::ShrAssign(..) => BinOp::ShrAssign,
            _ => unreachable!(),
        }
    }
}
impl From<&BinOp> for syn::BinOp {
    fn from(node: &BinOp) -> Self {
        match node {
            BinOp::Add => syn::BinOp::Add(default()),
            BinOp::Sub => syn::BinOp::Sub(default()),
            BinOp::Mul => syn::BinOp::Mul(default()),
            BinOp::Div => syn::BinOp::Div(default()),
            BinOp::Rem => syn::BinOp::Rem(default()),
            BinOp::And => syn::BinOp::And(default()),
            BinOp::Or => syn::BinOp::Or(default()),
            BinOp::BitXor => syn::BinOp::BitXor(default()),
            BinOp::BitAnd => syn::BinOp::BitAnd(default()),
            BinOp::BitOr => syn::BinOp::BitOr(default()),
            BinOp::Shl => syn::BinOp::Shl(default()),
            BinOp::Shr => syn::BinOp::Shr(default()),
            BinOp::Eq => syn::BinOp::Eq(default()),
            BinOp::Lt => syn::BinOp::Lt(default()),
            BinOp::Le => syn::BinOp::Le(default()),
            BinOp::Ne => syn::BinOp::Ne(default()),
            BinOp::Ge => syn::BinOp::Ge(default()),
            BinOp::Gt => syn::BinOp::Gt(default()),
            BinOp::AddAssign => syn::BinOp::AddAssign(default()),
            BinOp::SubAssign => syn::BinOp::SubAssign(default()),
            BinOp::MulAssign => syn::BinOp::MulAssign(default()),
            BinOp::DivAssign => syn::BinOp::DivAssign(default()),
            BinOp::RemAssign => syn::BinOp::RemAssign(default()),
            BinOp::BitXorAssign => syn::BinOp::BitXorAssign(default()),
            BinOp::BitAndAssign => syn::BinOp::BitAndAssign(default()),
            BinOp::BitOrAssign => syn::BinOp::BitOrAssign(default()),
            BinOp::ShlAssign => syn::BinOp::ShlAssign(default()),
            BinOp::ShrAssign => syn::BinOp::ShrAssign(default()),
        }
    }
}
syn_trait_impl!(syn::Block);
impl From<&syn::Block> for Block {
    fn from(node: &syn::Block) -> Self {
        Self {
            stmts: node.stmts.map_into(),
        }
    }
}
impl From<&Block> for syn::Block {
    fn from(node: &Block) -> Self {
        Self {
            brace_token: default(),
            stmts: node.stmts.map_into(),
        }
    }
}
syn_trait_impl!(syn::BoundLifetimes);
impl From<&syn::BoundLifetimes> for BoundLifetimes {
    fn from(node: &syn::BoundLifetimes) -> Self {
        Self {
            lifetimes: node.lifetimes.map_into(),
        }
    }
}
impl From<&BoundLifetimes> for syn::BoundLifetimes {
    fn from(node: &BoundLifetimes) -> Self {
        Self {
            for_token: default(),
            lt_token: default(),
            lifetimes: node.lifetimes.map_into(),
            gt_token: default(),
        }
    }
}
syn_trait_impl!(syn::ConstParam);
impl From<&syn::ConstParam> for ConstParam {
    fn from(node: &syn::ConstParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            ty: node.ty.ref_into(),
            eq_token: node.eq_token.is_some(),
            default: node.default.map_into(),
        }
    }
}
impl From<&ConstParam> for syn::ConstParam {
    fn from(node: &ConstParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            const_token: default(),
            ident: node.ident.ref_into(),
            colon_token: default(),
            ty: node.ty.ref_into(),
            eq_token: default_or_none(node.eq_token),
            default: node.default.map_into(),
        }
    }
}
syn_trait_impl!(syn::Constraint);
impl From<&syn::Constraint> for Constraint {
    fn from(node: &syn::Constraint) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&Constraint> for syn::Constraint {
    fn from(node: &Constraint) -> Self {
        Self {
            ident: node.ident.ref_into(),
            generics: node.generics.map_into(),
            colon_token: default(),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::Expr);
impl From<&syn::Expr> for Expr {
    fn from(node: &syn::Expr) -> Self {
        match node {
            syn::Expr::Array(_0) => Expr::Array((*_0).ref_into()),
            syn::Expr::Assign(_0) => Expr::Assign((*_0).ref_into()),
            syn::Expr::Async(_0) => Expr::Async((*_0).ref_into()),
            syn::Expr::Await(_0) => Expr::Await((*_0).ref_into()),
            syn::Expr::Binary(_0) => Expr::Binary((*_0).ref_into()),
            syn::Expr::Block(_0) => Expr::Block((*_0).ref_into()),
            syn::Expr::Break(_0) => Expr::Break((*_0).ref_into()),
            syn::Expr::Call(_0) => Expr::Call((*_0).ref_into()),
            syn::Expr::Cast(_0) => Expr::Cast((*_0).ref_into()),
            syn::Expr::Closure(_0) => Expr::Closure((*_0).ref_into()),
            syn::Expr::Const(_0) => Expr::Const((*_0).ref_into()),
            syn::Expr::Continue(_0) => Expr::Continue((*_0).ref_into()),
            syn::Expr::Field(_0) => Expr::Field((*_0).ref_into()),
            syn::Expr::ForLoop(_0) => Expr::ForLoop((*_0).ref_into()),
            syn::Expr::Group(_0) => Expr::Group((*_0).ref_into()),
            syn::Expr::If(_0) => Expr::If((*_0).ref_into()),
            syn::Expr::Index(_0) => Expr::Index((*_0).ref_into()),
            syn::Expr::Infer(_0) => Expr::Infer((*_0).ref_into()),
            syn::Expr::Let(_0) => Expr::Let((*_0).ref_into()),
            syn::Expr::Lit(_0) => Expr::Lit((*_0).ref_into()),
            syn::Expr::Loop(_0) => Expr::Loop((*_0).ref_into()),
            syn::Expr::Macro(_0) => Expr::Macro((*_0).ref_into()),
            syn::Expr::Match(_0) => Expr::Match((*_0).ref_into()),
            syn::Expr::MethodCall(_0) => Expr::MethodCall((*_0).ref_into()),
            syn::Expr::Paren(_0) => Expr::Paren((*_0).ref_into()),
            syn::Expr::Path(_0) => Expr::Path((*_0).ref_into()),
            syn::Expr::Range(_0) => Expr::Range((*_0).ref_into()),
            syn::Expr::Reference(_0) => Expr::Reference((*_0).ref_into()),
            syn::Expr::Repeat(_0) => Expr::Repeat((*_0).ref_into()),
            syn::Expr::Return(_0) => Expr::Return((*_0).ref_into()),
            syn::Expr::Struct(_0) => Expr::Struct((*_0).ref_into()),
            syn::Expr::Try(_0) => Expr::Try((*_0).ref_into()),
            syn::Expr::TryBlock(_0) => Expr::TryBlock((*_0).ref_into()),
            syn::Expr::Tuple(_0) => Expr::Tuple((*_0).ref_into()),
            syn::Expr::Unary(_0) => Expr::Unary((*_0).ref_into()),
            syn::Expr::Unsafe(_0) => Expr::Unsafe((*_0).ref_into()),
            syn::Expr::Verbatim(_0) => Expr::Verbatim((*_0).ref_into()),
            syn::Expr::While(_0) => Expr::While((*_0).ref_into()),
            syn::Expr::Yield(_0) => Expr::Yield((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&Expr> for syn::Expr {
    fn from(node: &Expr) -> Self {
        match node {
            Expr::Array(_0) => syn::Expr::Array((*_0).ref_into()),
            Expr::Assign(_0) => syn::Expr::Assign((*_0).ref_into()),
            Expr::Async(_0) => syn::Expr::Async((*_0).ref_into()),
            Expr::Await(_0) => syn::Expr::Await((*_0).ref_into()),
            Expr::Binary(_0) => syn::Expr::Binary((*_0).ref_into()),
            Expr::Block(_0) => syn::Expr::Block((*_0).ref_into()),
            Expr::Break(_0) => syn::Expr::Break((*_0).ref_into()),
            Expr::Call(_0) => syn::Expr::Call((*_0).ref_into()),
            Expr::Cast(_0) => syn::Expr::Cast((*_0).ref_into()),
            Expr::Closure(_0) => syn::Expr::Closure((*_0).ref_into()),
            Expr::Const(_0) => syn::Expr::Const((*_0).ref_into()),
            Expr::Continue(_0) => syn::Expr::Continue((*_0).ref_into()),
            Expr::Field(_0) => syn::Expr::Field((*_0).ref_into()),
            Expr::ForLoop(_0) => syn::Expr::ForLoop((*_0).ref_into()),
            Expr::Group(_0) => syn::Expr::Group((*_0).ref_into()),
            Expr::If(_0) => syn::Expr::If((*_0).ref_into()),
            Expr::Index(_0) => syn::Expr::Index((*_0).ref_into()),
            Expr::Infer(_0) => syn::Expr::Infer((*_0).ref_into()),
            Expr::Let(_0) => syn::Expr::Let((*_0).ref_into()),
            Expr::Lit(_0) => syn::Expr::Lit((*_0).ref_into()),
            Expr::Loop(_0) => syn::Expr::Loop((*_0).ref_into()),
            Expr::Macro(_0) => syn::Expr::Macro((*_0).ref_into()),
            Expr::Match(_0) => syn::Expr::Match((*_0).ref_into()),
            Expr::MethodCall(_0) => syn::Expr::MethodCall((*_0).ref_into()),
            Expr::Paren(_0) => syn::Expr::Paren((*_0).ref_into()),
            Expr::Path(_0) => syn::Expr::Path((*_0).ref_into()),
            Expr::Range(_0) => syn::Expr::Range((*_0).ref_into()),
            Expr::Reference(_0) => syn::Expr::Reference((*_0).ref_into()),
            Expr::Repeat(_0) => syn::Expr::Repeat((*_0).ref_into()),
            Expr::Return(_0) => syn::Expr::Return((*_0).ref_into()),
            Expr::Struct(_0) => syn::Expr::Struct((*_0).ref_into()),
            Expr::Try(_0) => syn::Expr::Try((*_0).ref_into()),
            Expr::TryBlock(_0) => syn::Expr::TryBlock((*_0).ref_into()),
            Expr::Tuple(_0) => syn::Expr::Tuple((*_0).ref_into()),
            Expr::Unary(_0) => syn::Expr::Unary((*_0).ref_into()),
            Expr::Unsafe(_0) => syn::Expr::Unsafe((*_0).ref_into()),
            Expr::Verbatim(_0) => syn::Expr::Verbatim((*_0).ref_into()),
            Expr::While(_0) => syn::Expr::While((*_0).ref_into()),
            Expr::Yield(_0) => syn::Expr::Yield((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ExprArray);
impl From<&syn::ExprArray> for ExprArray {
    fn from(node: &syn::ExprArray) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            elems: node.elems.map_into(),
        }
    }
}
impl From<&ExprArray> for syn::ExprArray {
    fn from(node: &ExprArray) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            bracket_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprAssign);
impl From<&syn::ExprAssign> for ExprAssign {
    fn from(node: &syn::ExprAssign) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            left: node.left.map_into(),
            right: node.right.map_into(),
        }
    }
}
impl From<&ExprAssign> for syn::ExprAssign {
    fn from(node: &ExprAssign) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            left: node.left.map_into(),
            eq_token: default(),
            right: node.right.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprAsync);
impl From<&syn::ExprAsync> for ExprAsync {
    fn from(node: &syn::ExprAsync) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            capture: node.capture.is_some(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ExprAsync> for syn::ExprAsync {
    fn from(node: &ExprAsync) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            async_token: default(),
            capture: default_or_none(node.capture),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprAwait);
impl From<&syn::ExprAwait> for ExprAwait {
    fn from(node: &syn::ExprAwait) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            base: node.base.map_into(),
        }
    }
}
impl From<&ExprAwait> for syn::ExprAwait {
    fn from(node: &ExprAwait) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            base: node.base.map_into(),
            dot_token: default(),
            await_token: default(),
        }
    }
}
syn_trait_impl!(syn::ExprBinary);
impl From<&syn::ExprBinary> for ExprBinary {
    fn from(node: &syn::ExprBinary) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            left: node.left.map_into(),
            op: node.op.ref_into(),
            right: node.right.map_into(),
        }
    }
}
impl From<&ExprBinary> for syn::ExprBinary {
    fn from(node: &ExprBinary) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            left: node.left.map_into(),
            op: node.op.ref_into(),
            right: node.right.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprBlock);
impl From<&syn::ExprBlock> for ExprBlock {
    fn from(node: &syn::ExprBlock) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ExprBlock> for syn::ExprBlock {
    fn from(node: &ExprBlock) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprBreak);
impl From<&syn::ExprBreak> for ExprBreak {
    fn from(node: &syn::ExprBreak) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
impl From<&ExprBreak> for syn::ExprBreak {
    fn from(node: &ExprBreak) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            break_token: default(),
            label: node.label.map_into(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
syn_trait_impl!(syn::ExprCall);
impl From<&syn::ExprCall> for ExprCall {
    fn from(node: &syn::ExprCall) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            func: node.func.map_into(),
            args: node.args.map_into(),
        }
    }
}
impl From<&ExprCall> for syn::ExprCall {
    fn from(node: &ExprCall) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            func: node.func.map_into(),
            paren_token: default(),
            args: node.args.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprCast);
impl From<&syn::ExprCast> for ExprCast {
    fn from(node: &syn::ExprCast) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            ty: node.ty.map_into(),
        }
    }
}
impl From<&ExprCast> for syn::ExprCast {
    fn from(node: &ExprCast) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            as_token: default(),
            ty: node.ty.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprClosure);
impl From<&syn::ExprClosure> for ExprClosure {
    fn from(node: &syn::ExprClosure) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lifetimes: node.lifetimes.map_into(),
            constness: node.constness.is_some(),
            movability: node.movability.is_some(),
            asyncness: node.asyncness.is_some(),
            capture: node.capture.is_some(),
            inputs: node.inputs.map_into(),
            output: node.output.ref_into(),
            body: node.body.map_into(),
        }
    }
}
impl From<&ExprClosure> for syn::ExprClosure {
    fn from(node: &ExprClosure) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lifetimes: node.lifetimes.map_into(),
            constness: default_or_none(node.constness),
            movability: default_or_none(node.movability),
            asyncness: default_or_none(node.asyncness),
            capture: default_or_none(node.capture),
            or1_token: default(),
            inputs: node.inputs.map_into(),
            or2_token: default(),
            output: node.output.ref_into(),
            body: node.body.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprConst);
impl From<&syn::ExprConst> for ExprConst {
    fn from(node: &syn::ExprConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ExprConst> for syn::ExprConst {
    fn from(node: &ExprConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            const_token: default(),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprContinue);
impl From<&syn::ExprContinue> for ExprContinue {
    fn from(node: &syn::ExprContinue) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
        }
    }
}
impl From<&ExprContinue> for syn::ExprContinue {
    fn from(node: &ExprContinue) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            continue_token: default(),
            label: node.label.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprField);
impl From<&syn::ExprField> for ExprField {
    fn from(node: &syn::ExprField) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            base: node.base.map_into(),
            member: node.member.ref_into(),
        }
    }
}
impl From<&ExprField> for syn::ExprField {
    fn from(node: &ExprField) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            base: node.base.map_into(),
            dot_token: default(),
            member: node.member.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprForLoop);
impl From<&syn::ExprForLoop> for ExprForLoop {
    fn from(node: &syn::ExprForLoop) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            pat: node.pat.map_into(),
            expr: node.expr.map_into(),
            body: node.body.ref_into(),
        }
    }
}
impl From<&ExprForLoop> for syn::ExprForLoop {
    fn from(node: &ExprForLoop) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            for_token: default(),
            pat: node.pat.map_into(),
            in_token: default(),
            expr: node.expr.map_into(),
            body: node.body.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprGroup);
impl From<&syn::ExprGroup> for ExprGroup {
    fn from(node: &syn::ExprGroup) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprGroup> for syn::ExprGroup {
    fn from(node: &ExprGroup) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            group_token: default(),
            expr: node.expr.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprIf);
impl From<&syn::ExprIf> for ExprIf {
    fn from(node: &syn::ExprIf) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            cond: node.cond.map_into(),
            then_branch: node.then_branch.ref_into(),
            else_branch: node.else_branch.ref_map(|(_0, _1)| (*_1).map_into()),
        }
    }
}
impl From<&ExprIf> for syn::ExprIf {
    fn from(node: &ExprIf) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            if_token: default(),
            cond: node.cond.map_into(),
            then_branch: node.then_branch.ref_into(),
            else_branch: node.else_branch.ref_map(|_1| (default(), (*_1).map_into())),
        }
    }
}
syn_trait_impl!(syn::ExprIndex);
impl From<&syn::ExprIndex> for ExprIndex {
    fn from(node: &syn::ExprIndex) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            index: node.index.map_into(),
        }
    }
}
impl From<&ExprIndex> for syn::ExprIndex {
    fn from(node: &ExprIndex) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            bracket_token: default(),
            index: node.index.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprInfer);
impl From<&syn::ExprInfer> for ExprInfer {
    fn from(node: &syn::ExprInfer) -> Self {
        Self {
            attrs: node.attrs.map_into(),
        }
    }
}
impl From<&ExprInfer> for syn::ExprInfer {
    fn from(node: &ExprInfer) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            underscore_token: default(),
        }
    }
}
syn_trait_impl!(syn::ExprLet);
impl From<&syn::ExprLet> for ExprLet {
    fn from(node: &syn::ExprLet) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprLet> for syn::ExprLet {
    fn from(node: &ExprLet) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            let_token: default(),
            pat: node.pat.map_into(),
            eq_token: default(),
            expr: node.expr.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprLit);
impl From<&syn::ExprLit> for ExprLit {
    fn from(node: &syn::ExprLit) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lit: node.lit.ref_into(),
        }
    }
}
impl From<&ExprLit> for syn::ExprLit {
    fn from(node: &ExprLit) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lit: node.lit.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprLoop);
impl From<&syn::ExprLoop> for ExprLoop {
    fn from(node: &syn::ExprLoop) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            body: node.body.ref_into(),
        }
    }
}
impl From<&ExprLoop> for syn::ExprLoop {
    fn from(node: &ExprLoop) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            loop_token: default(),
            body: node.body.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprMacro);
impl From<&syn::ExprMacro> for ExprMacro {
    fn from(node: &syn::ExprMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
        }
    }
}
impl From<&ExprMacro> for syn::ExprMacro {
    fn from(node: &ExprMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprMethodCall);
impl From<&syn::ExprMethodCall> for ExprMethodCall {
    fn from(node: &syn::ExprMethodCall) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            receiver: node.receiver.map_into(),
            method: node.method.ref_into(),
            turbofish: node.turbofish.map_into(),
            args: node.args.map_into(),
        }
    }
}
impl From<&ExprMethodCall> for syn::ExprMethodCall {
    fn from(node: &ExprMethodCall) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            receiver: node.receiver.map_into(),
            dot_token: default(),
            method: node.method.ref_into(),
            turbofish: node.turbofish.map_into(),
            paren_token: default(),
            args: node.args.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprParen);
impl From<&syn::ExprParen> for ExprParen {
    fn from(node: &syn::ExprParen) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprParen> for syn::ExprParen {
    fn from(node: &ExprParen) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            paren_token: default(),
            expr: node.expr.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprPath);
impl From<&syn::ExprPath> for ExprPath {
    fn from(node: &syn::ExprPath) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
        }
    }
}
impl From<&ExprPath> for syn::ExprPath {
    fn from(node: &ExprPath) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprRange);
impl From<&syn::ExprRange> for ExprRange {
    fn from(node: &syn::ExprRange) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            start: node.start.ref_map(MapInto::map_into),
            limits: node.limits.ref_into(),
            end: node.end.ref_map(MapInto::map_into),
        }
    }
}
impl From<&ExprRange> for syn::ExprRange {
    fn from(node: &ExprRange) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            start: node.start.ref_map(MapInto::map_into),
            limits: node.limits.ref_into(),
            end: node.end.ref_map(MapInto::map_into),
        }
    }
}
syn_trait_impl!(syn::ExprReference);
impl From<&syn::ExprReference> for ExprReference {
    fn from(node: &syn::ExprReference) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mutability: node.mutability.is_some(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprReference> for syn::ExprReference {
    fn from(node: &ExprReference) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            and_token: default(),
            mutability: default_or_none(node.mutability),
            expr: node.expr.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprRepeat);
impl From<&syn::ExprRepeat> for ExprRepeat {
    fn from(node: &syn::ExprRepeat) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            len: node.len.map_into(),
        }
    }
}
impl From<&ExprRepeat> for syn::ExprRepeat {
    fn from(node: &ExprRepeat) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            bracket_token: default(),
            expr: node.expr.map_into(),
            semi_token: default(),
            len: node.len.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprReturn);
impl From<&syn::ExprReturn> for ExprReturn {
    fn from(node: &syn::ExprReturn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
impl From<&ExprReturn> for syn::ExprReturn {
    fn from(node: &ExprReturn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            return_token: default(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
syn_trait_impl!(syn::ExprStruct);
impl From<&syn::ExprStruct> for ExprStruct {
    fn from(node: &syn::ExprStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            fields: node.fields.map_into(),
            dot2_token: node.dot2_token.is_some(),
            rest: node.rest.ref_map(MapInto::map_into),
        }
    }
}
impl From<&ExprStruct> for syn::ExprStruct {
    fn from(node: &ExprStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            brace_token: default(),
            fields: node.fields.map_into(),
            dot2_token: default_or_none(node.dot2_token),
            rest: node.rest.ref_map(MapInto::map_into),
        }
    }
}
syn_trait_impl!(syn::ExprTry);
impl From<&syn::ExprTry> for ExprTry {
    fn from(node: &syn::ExprTry) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprTry> for syn::ExprTry {
    fn from(node: &ExprTry) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.map_into(),
            question_token: default(),
        }
    }
}
syn_trait_impl!(syn::ExprTryBlock);
impl From<&syn::ExprTryBlock> for ExprTryBlock {
    fn from(node: &syn::ExprTryBlock) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ExprTryBlock> for syn::ExprTryBlock {
    fn from(node: &ExprTryBlock) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            try_token: default(),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprTuple);
impl From<&syn::ExprTuple> for ExprTuple {
    fn from(node: &syn::ExprTuple) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            elems: node.elems.map_into(),
        }
    }
}
impl From<&ExprTuple> for syn::ExprTuple {
    fn from(node: &ExprTuple) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            paren_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprUnary);
impl From<&syn::ExprUnary> for ExprUnary {
    fn from(node: &syn::ExprUnary) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            op: node.op.ref_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ExprUnary> for syn::ExprUnary {
    fn from(node: &ExprUnary) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            op: node.op.ref_into(),
            expr: node.expr.map_into(),
        }
    }
}
syn_trait_impl!(syn::ExprUnsafe);
impl From<&syn::ExprUnsafe> for ExprUnsafe {
    fn from(node: &syn::ExprUnsafe) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ExprUnsafe> for syn::ExprUnsafe {
    fn from(node: &ExprUnsafe) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            unsafe_token: default(),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprWhile);
impl From<&syn::ExprWhile> for ExprWhile {
    fn from(node: &syn::ExprWhile) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            cond: node.cond.map_into(),
            body: node.body.ref_into(),
        }
    }
}
impl From<&ExprWhile> for syn::ExprWhile {
    fn from(node: &ExprWhile) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            label: node.label.map_into(),
            while_token: default(),
            cond: node.cond.map_into(),
            body: node.body.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ExprYield);
impl From<&syn::ExprYield> for ExprYield {
    fn from(node: &syn::ExprYield) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
impl From<&ExprYield> for syn::ExprYield {
    fn from(node: &ExprYield) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            yield_token: default(),
            expr: node.expr.ref_map(MapInto::map_into),
        }
    }
}
syn_trait_impl!(syn::Field);
impl From<&syn::Field> for Field {
    fn from(node: &syn::Field) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.map_into(),
            colon_token: node.colon_token.is_some(),
            ty: node.ty.ref_into(),
        }
    }
}
impl From<&Field> for syn::Field {
    fn from(node: &Field) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.map_into(),
            colon_token: default_or_none(node.colon_token),
            ty: node.ty.ref_into(),
        }
    }
}
syn_trait_impl!(syn::FieldMutability);
impl From<&syn::FieldMutability> for FieldMutability {
    fn from(node: &syn::FieldMutability) -> Self {
        match node {
            syn::FieldMutability::None => FieldMutability::None,
            _ => unreachable!(),
        }
    }
}
impl From<&FieldMutability> for syn::FieldMutability {
    fn from(node: &FieldMutability) -> Self {
        match node {
            FieldMutability::None => syn::FieldMutability::None,
        }
    }
}
syn_trait_impl!(syn::FieldPat);
impl From<&syn::FieldPat> for FieldPat {
    fn from(node: &syn::FieldPat) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            member: node.member.ref_into(),
            colon_token: node.colon_token.is_some(),
            pat: node.pat.map_into(),
        }
    }
}
impl From<&FieldPat> for syn::FieldPat {
    fn from(node: &FieldPat) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            member: node.member.ref_into(),
            colon_token: default_or_none(node.colon_token),
            pat: node.pat.map_into(),
        }
    }
}
syn_trait_impl!(syn::FieldValue);
impl From<&syn::FieldValue> for FieldValue {
    fn from(node: &syn::FieldValue) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            member: node.member.ref_into(),
            colon_token: node.colon_token.is_some(),
            expr: node.expr.ref_into(),
        }
    }
}
impl From<&FieldValue> for syn::FieldValue {
    fn from(node: &FieldValue) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            member: node.member.ref_into(),
            colon_token: default_or_none(node.colon_token),
            expr: node.expr.ref_into(),
        }
    }
}
syn_trait_impl!(syn::Fields);
impl From<&syn::Fields> for Fields {
    fn from(node: &syn::Fields) -> Self {
        match node {
            syn::Fields::Named(_0) => Fields::Named((*_0).ref_into()),
            syn::Fields::Unnamed(_0) => Fields::Unnamed((*_0).ref_into()),
            syn::Fields::Unit => Fields::Unit,
        }
    }
}
impl From<&Fields> for syn::Fields {
    fn from(node: &Fields) -> Self {
        match node {
            Fields::Named(_0) => syn::Fields::Named((*_0).ref_into()),
            Fields::Unnamed(_0) => syn::Fields::Unnamed((*_0).ref_into()),
            Fields::Unit => syn::Fields::Unit,
        }
    }
}
syn_trait_impl!(syn::FieldsNamed);
impl From<&syn::FieldsNamed> for FieldsNamed {
    fn from(node: &syn::FieldsNamed) -> Self {
        Self {
            named: node.named.map_into(),
        }
    }
}
impl From<&FieldsNamed> for syn::FieldsNamed {
    fn from(node: &FieldsNamed) -> Self {
        Self {
            brace_token: default(),
            named: node.named.map_into(),
        }
    }
}
syn_trait_impl!(syn::FieldsUnnamed);
impl From<&syn::FieldsUnnamed> for FieldsUnnamed {
    fn from(node: &syn::FieldsUnnamed) -> Self {
        Self {
            unnamed: node.unnamed.map_into(),
        }
    }
}
impl From<&FieldsUnnamed> for syn::FieldsUnnamed {
    fn from(node: &FieldsUnnamed) -> Self {
        Self {
            paren_token: default(),
            unnamed: node.unnamed.map_into(),
        }
    }
}
syn_trait_impl!(syn::File);
impl From<&syn::File> for File {
    fn from(node: &syn::File) -> Self {
        Self {
            shebang: node.shebang.map_into(),
            attrs: node.attrs.map_into(),
            items: node.items.map_into(),
        }
    }
}
impl From<&File> for syn::File {
    fn from(node: &File) -> Self {
        Self {
            shebang: node.shebang.map_into(),
            attrs: node.attrs.map_into(),
            items: node.items.map_into(),
        }
    }
}
syn_trait_impl!(syn::FnArg);
impl From<&syn::FnArg> for FnArg {
    fn from(node: &syn::FnArg) -> Self {
        match node {
            syn::FnArg::Receiver(_0) => FnArg::Receiver((*_0).ref_into()),
            syn::FnArg::Typed(_0) => FnArg::Typed((*_0).ref_into()),
        }
    }
}
impl From<&FnArg> for syn::FnArg {
    fn from(node: &FnArg) -> Self {
        match node {
            FnArg::Receiver(_0) => syn::FnArg::Receiver((*_0).ref_into()),
            FnArg::Typed(_0) => syn::FnArg::Typed((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ForeignItem);
impl From<&syn::ForeignItem> for ForeignItem {
    fn from(node: &syn::ForeignItem) -> Self {
        match node {
            syn::ForeignItem::Fn(_0) => ForeignItem::Fn((*_0).ref_into()),
            syn::ForeignItem::Static(_0) => ForeignItem::Static((*_0).ref_into()),
            syn::ForeignItem::Type(_0) => ForeignItem::Type((*_0).ref_into()),
            syn::ForeignItem::Macro(_0) => ForeignItem::Macro((*_0).ref_into()),
            syn::ForeignItem::Verbatim(_0) => ForeignItem::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&ForeignItem> for syn::ForeignItem {
    fn from(node: &ForeignItem) -> Self {
        match node {
            ForeignItem::Fn(_0) => syn::ForeignItem::Fn((*_0).ref_into()),
            ForeignItem::Static(_0) => syn::ForeignItem::Static((*_0).ref_into()),
            ForeignItem::Type(_0) => syn::ForeignItem::Type((*_0).ref_into()),
            ForeignItem::Macro(_0) => syn::ForeignItem::Macro((*_0).ref_into()),
            ForeignItem::Verbatim(_0) => syn::ForeignItem::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ForeignItemFn);
impl From<&syn::ForeignItemFn> for ForeignItemFn {
    fn from(node: &syn::ForeignItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            sig: node.sig.ref_into(),
        }
    }
}
impl From<&ForeignItemFn> for syn::ForeignItemFn {
    fn from(node: &ForeignItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            sig: node.sig.ref_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ForeignItemMacro);
impl From<&syn::ForeignItemMacro> for ForeignItemMacro {
    fn from(node: &syn::ForeignItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: node.semi_token.is_some(),
        }
    }
}
impl From<&ForeignItemMacro> for syn::ForeignItemMacro {
    fn from(node: &ForeignItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: default_or_none(node.semi_token),
        }
    }
}
syn_trait_impl!(syn::ForeignItemStatic);
impl From<&syn::ForeignItemStatic> for ForeignItemStatic {
    fn from(node: &syn::ForeignItemStatic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.ref_into(),
            ty: node.ty.map_into(),
        }
    }
}
impl From<&ForeignItemStatic> for syn::ForeignItemStatic {
    fn from(node: &ForeignItemStatic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            static_token: default(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.ref_into(),
            colon_token: default(),
            ty: node.ty.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ForeignItemType);
impl From<&syn::ForeignItemType> for ForeignItemType {
    fn from(node: &syn::ForeignItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
        }
    }
}
impl From<&ForeignItemType> for syn::ForeignItemType {
    fn from(node: &ForeignItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            type_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::GenericArgument);
impl From<&syn::GenericArgument> for GenericArgument {
    fn from(node: &syn::GenericArgument) -> Self {
        match node {
            syn::GenericArgument::Lifetime(_0) => {
                GenericArgument::Lifetime((*_0).ref_into())
            }
            syn::GenericArgument::Type(_0) => GenericArgument::Type((*_0).ref_into()),
            syn::GenericArgument::Const(_0) => GenericArgument::Const((*_0).ref_into()),
            syn::GenericArgument::AssocType(_0) => {
                GenericArgument::AssocType((*_0).ref_into())
            }
            syn::GenericArgument::AssocConst(_0) => {
                GenericArgument::AssocConst((*_0).ref_into())
            }
            syn::GenericArgument::Constraint(_0) => {
                GenericArgument::Constraint((*_0).ref_into())
            }
            _ => unreachable!(),
        }
    }
}
impl From<&GenericArgument> for syn::GenericArgument {
    fn from(node: &GenericArgument) -> Self {
        match node {
            GenericArgument::Lifetime(_0) => {
                syn::GenericArgument::Lifetime((*_0).ref_into())
            }
            GenericArgument::Type(_0) => syn::GenericArgument::Type((*_0).ref_into()),
            GenericArgument::Const(_0) => syn::GenericArgument::Const((*_0).ref_into()),
            GenericArgument::AssocType(_0) => {
                syn::GenericArgument::AssocType((*_0).ref_into())
            }
            GenericArgument::AssocConst(_0) => {
                syn::GenericArgument::AssocConst((*_0).ref_into())
            }
            GenericArgument::Constraint(_0) => {
                syn::GenericArgument::Constraint((*_0).ref_into())
            }
        }
    }
}
syn_trait_impl!(syn::GenericParam);
impl From<&syn::GenericParam> for GenericParam {
    fn from(node: &syn::GenericParam) -> Self {
        match node {
            syn::GenericParam::Lifetime(_0) => GenericParam::Lifetime((*_0).ref_into()),
            syn::GenericParam::Type(_0) => GenericParam::Type((*_0).ref_into()),
            syn::GenericParam::Const(_0) => GenericParam::Const((*_0).ref_into()),
        }
    }
}
impl From<&GenericParam> for syn::GenericParam {
    fn from(node: &GenericParam) -> Self {
        match node {
            GenericParam::Lifetime(_0) => syn::GenericParam::Lifetime((*_0).ref_into()),
            GenericParam::Type(_0) => syn::GenericParam::Type((*_0).ref_into()),
            GenericParam::Const(_0) => syn::GenericParam::Const((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ImplItem);
impl From<&syn::ImplItem> for ImplItem {
    fn from(node: &syn::ImplItem) -> Self {
        match node {
            syn::ImplItem::Const(_0) => ImplItem::Const((*_0).ref_into()),
            syn::ImplItem::Fn(_0) => ImplItem::Fn((*_0).ref_into()),
            syn::ImplItem::Type(_0) => ImplItem::Type((*_0).ref_into()),
            syn::ImplItem::Macro(_0) => ImplItem::Macro((*_0).ref_into()),
            syn::ImplItem::Verbatim(_0) => ImplItem::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&ImplItem> for syn::ImplItem {
    fn from(node: &ImplItem) -> Self {
        match node {
            ImplItem::Const(_0) => syn::ImplItem::Const((*_0).ref_into()),
            ImplItem::Fn(_0) => syn::ImplItem::Fn((*_0).ref_into()),
            ImplItem::Type(_0) => syn::ImplItem::Type((*_0).ref_into()),
            ImplItem::Macro(_0) => syn::ImplItem::Macro((*_0).ref_into()),
            ImplItem::Verbatim(_0) => syn::ImplItem::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ImplItemConst);
impl From<&syn::ImplItemConst> for ImplItemConst {
    fn from(node: &syn::ImplItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: node.defaultness.is_some(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            ty: node.ty.ref_into(),
            expr: node.expr.ref_into(),
        }
    }
}
impl From<&ImplItemConst> for syn::ImplItemConst {
    fn from(node: &ImplItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: default_or_none(node.defaultness),
            const_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: default(),
            ty: node.ty.ref_into(),
            eq_token: default(),
            expr: node.expr.ref_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ImplItemFn);
impl From<&syn::ImplItemFn> for ImplItemFn {
    fn from(node: &syn::ImplItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: node.defaultness.is_some(),
            sig: node.sig.ref_into(),
            block: node.block.ref_into(),
        }
    }
}
impl From<&ImplItemFn> for syn::ImplItemFn {
    fn from(node: &ImplItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: default_or_none(node.defaultness),
            sig: node.sig.ref_into(),
            block: node.block.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ImplItemMacro);
impl From<&syn::ImplItemMacro> for ImplItemMacro {
    fn from(node: &syn::ImplItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: node.semi_token.is_some(),
        }
    }
}
impl From<&ImplItemMacro> for syn::ImplItemMacro {
    fn from(node: &ImplItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: default_or_none(node.semi_token),
        }
    }
}
syn_trait_impl!(syn::ImplItemType);
impl From<&syn::ImplItemType> for ImplItemType {
    fn from(node: &syn::ImplItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: node.defaultness.is_some(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            ty: node.ty.ref_into(),
        }
    }
}
impl From<&ImplItemType> for syn::ImplItemType {
    fn from(node: &ImplItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            defaultness: default_or_none(node.defaultness),
            type_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            eq_token: default(),
            ty: node.ty.ref_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ImplRestriction);
impl From<&syn::ImplRestriction> for ImplRestriction {
    fn from(node: &syn::ImplRestriction) -> Self {
        match node {
            _ => unreachable!(),
        }
    }
}
impl From<&ImplRestriction> for syn::ImplRestriction {
    fn from(node: &ImplRestriction) -> Self {
        match node {
            _ => unreachable!(),
        }
    }
}
syn_trait_impl!(syn::Index);
impl From<&syn::Index> for Index {
    fn from(node: &syn::Index) -> Self {
        Self { index: node.index }
    }
}
impl From<&Index> for syn::Index {
    fn from(node: &Index) -> Self {
        Self {
            index: node.index,
            span: proc_macro2::Span::call_site(),
        }
    }
}
syn_trait_impl!(syn::Item);
impl From<&syn::Item> for Item {
    fn from(node: &syn::Item) -> Self {
        match node {
            syn::Item::Const(_0) => Item::Const((*_0).ref_into()),
            syn::Item::Enum(_0) => Item::Enum((*_0).ref_into()),
            syn::Item::ExternCrate(_0) => Item::ExternCrate((*_0).ref_into()),
            syn::Item::Fn(_0) => Item::Fn((*_0).ref_into()),
            syn::Item::ForeignMod(_0) => Item::ForeignMod((*_0).ref_into()),
            syn::Item::Impl(_0) => Item::Impl((*_0).ref_into()),
            syn::Item::Macro(_0) => Item::Macro((*_0).ref_into()),
            syn::Item::Mod(_0) => Item::Mod((*_0).ref_into()),
            syn::Item::Static(_0) => Item::Static((*_0).ref_into()),
            syn::Item::Struct(_0) => Item::Struct((*_0).ref_into()),
            syn::Item::Trait(_0) => Item::Trait((*_0).ref_into()),
            syn::Item::TraitAlias(_0) => Item::TraitAlias((*_0).ref_into()),
            syn::Item::Type(_0) => Item::Type((*_0).ref_into()),
            syn::Item::Union(_0) => Item::Union((*_0).ref_into()),
            syn::Item::Use(_0) => Item::Use((*_0).ref_into()),
            syn::Item::Verbatim(_0) => Item::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&Item> for syn::Item {
    fn from(node: &Item) -> Self {
        match node {
            Item::Const(_0) => syn::Item::Const((*_0).ref_into()),
            Item::Enum(_0) => syn::Item::Enum((*_0).ref_into()),
            Item::ExternCrate(_0) => syn::Item::ExternCrate((*_0).ref_into()),
            Item::Fn(_0) => syn::Item::Fn((*_0).ref_into()),
            Item::ForeignMod(_0) => syn::Item::ForeignMod((*_0).ref_into()),
            Item::Impl(_0) => syn::Item::Impl((*_0).ref_into()),
            Item::Macro(_0) => syn::Item::Macro((*_0).ref_into()),
            Item::Mod(_0) => syn::Item::Mod((*_0).ref_into()),
            Item::Static(_0) => syn::Item::Static((*_0).ref_into()),
            Item::Struct(_0) => syn::Item::Struct((*_0).ref_into()),
            Item::Trait(_0) => syn::Item::Trait((*_0).ref_into()),
            Item::TraitAlias(_0) => syn::Item::TraitAlias((*_0).ref_into()),
            Item::Type(_0) => syn::Item::Type((*_0).ref_into()),
            Item::Union(_0) => syn::Item::Union((*_0).ref_into()),
            Item::Use(_0) => syn::Item::Use((*_0).ref_into()),
            Item::Verbatim(_0) => syn::Item::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::ItemConst);
impl From<&syn::ItemConst> for ItemConst {
    fn from(node: &syn::ItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            ty: node.ty.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ItemConst> for syn::ItemConst {
    fn from(node: &ItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            const_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: default(),
            ty: node.ty.map_into(),
            eq_token: default(),
            expr: node.expr.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ItemEnum);
impl From<&syn::ItemEnum> for ItemEnum {
    fn from(node: &syn::ItemEnum) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            variants: node.variants.map_into(),
        }
    }
}
impl From<&ItemEnum> for syn::ItemEnum {
    fn from(node: &ItemEnum) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            enum_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            brace_token: default(),
            variants: node.variants.map_into(),
        }
    }
}
syn_trait_impl!(syn::ItemExternCrate);
impl From<&syn::ItemExternCrate> for ItemExternCrate {
    fn from(node: &syn::ItemExternCrate) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            rename: node.rename.ref_map(|(_0, _1)| (*_1).ref_into()),
        }
    }
}
impl From<&ItemExternCrate> for syn::ItemExternCrate {
    fn from(node: &ItemExternCrate) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            extern_token: default(),
            crate_token: default(),
            ident: node.ident.ref_into(),
            rename: node.rename.ref_map(|_1| (default(), (*_1).ref_into())),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ItemFn);
impl From<&syn::ItemFn> for ItemFn {
    fn from(node: &syn::ItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            sig: node.sig.ref_into(),
            block: node.block.map_into(),
        }
    }
}
impl From<&ItemFn> for syn::ItemFn {
    fn from(node: &ItemFn) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            sig: node.sig.ref_into(),
            block: node.block.map_into(),
        }
    }
}
syn_trait_impl!(syn::ItemForeignMod);
impl From<&syn::ItemForeignMod> for ItemForeignMod {
    fn from(node: &syn::ItemForeignMod) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            unsafety: node.unsafety.is_some(),
            abi: node.abi.ref_into(),
            items: node.items.map_into(),
        }
    }
}
impl From<&ItemForeignMod> for syn::ItemForeignMod {
    fn from(node: &ItemForeignMod) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            unsafety: default_or_none(node.unsafety),
            abi: node.abi.ref_into(),
            brace_token: default(),
            items: node.items.map_into(),
        }
    }
}
syn_trait_impl!(syn::ItemImpl);
impl From<&syn::ItemImpl> for ItemImpl {
    fn from(node: &syn::ItemImpl) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            defaultness: node.defaultness.is_some(),
            unsafety: node.unsafety.is_some(),
            generics: node.generics.ref_into(),
            trait_: node
                .trait_
                .ref_map(|(_0, _1, _2)| ((*_0).is_some(), (*_1).ref_into())),
            self_ty: node.self_ty.map_into(),
            items: node.items.map_into(),
        }
    }
}
impl From<&ItemImpl> for syn::ItemImpl {
    fn from(node: &ItemImpl) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            defaultness: default_or_none(node.defaultness),
            unsafety: default_or_none(node.unsafety),
            impl_token: default(),
            generics: node.generics.ref_into(),
            trait_: node
                .trait_
                .ref_map(|(_0, _1)| (
                    default_or_none((*_0)),
                    (*_1).ref_into(),
                    default(),
                )),
            self_ty: node.self_ty.map_into(),
            brace_token: default(),
            items: node.items.map_into(),
        }
    }
}
syn_trait_impl!(syn::ItemMacro);
impl From<&syn::ItemMacro> for ItemMacro {
    fn from(node: &syn::ItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.map_into(),
            mac: node.mac.ref_into(),
            semi_token: node.semi_token.is_some(),
        }
    }
}
impl From<&ItemMacro> for syn::ItemMacro {
    fn from(node: &ItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.map_into(),
            mac: node.mac.ref_into(),
            semi_token: default_or_none(node.semi_token),
        }
    }
}
syn_trait_impl!(syn::ItemMod);
impl From<&syn::ItemMod> for ItemMod {
    fn from(node: &syn::ItemMod) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            unsafety: node.unsafety.is_some(),
            ident: node.ident.ref_into(),
            content: node.content.ref_map(|(_0, _1)| (*_1).map_into()),
            semi: node.semi.is_some(),
        }
    }
}
impl From<&ItemMod> for syn::ItemMod {
    fn from(node: &ItemMod) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            unsafety: default_or_none(node.unsafety),
            mod_token: default(),
            ident: node.ident.ref_into(),
            content: node.content.ref_map(|_1| (default(), (*_1).map_into())),
            semi: default_or_none(node.semi),
        }
    }
}
syn_trait_impl!(syn::ItemStatic);
impl From<&syn::ItemStatic> for ItemStatic {
    fn from(node: &syn::ItemStatic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.ref_into(),
            ty: node.ty.map_into(),
            expr: node.expr.map_into(),
        }
    }
}
impl From<&ItemStatic> for syn::ItemStatic {
    fn from(node: &ItemStatic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            static_token: default(),
            mutability: node.mutability.ref_into(),
            ident: node.ident.ref_into(),
            colon_token: default(),
            ty: node.ty.map_into(),
            eq_token: default(),
            expr: node.expr.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ItemTrait);
impl From<&syn::ItemTrait> for ItemTrait {
    fn from(node: &syn::ItemTrait) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            unsafety: node.unsafety.is_some(),
            auto_token: node.auto_token.is_some(),
            restriction: node.restriction.map_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: node.colon_token.is_some(),
            supertraits: node.supertraits.map_into(),
            items: node.items.map_into(),
        }
    }
}
impl From<&ItemTrait> for syn::ItemTrait {
    fn from(node: &ItemTrait) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            unsafety: default_or_none(node.unsafety),
            auto_token: default_or_none(node.auto_token),
            restriction: node.restriction.map_into(),
            trait_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: default_or_none(node.colon_token),
            supertraits: node.supertraits.map_into(),
            brace_token: default(),
            items: node.items.map_into(),
        }
    }
}
syn_trait_impl!(syn::ItemTraitAlias);
impl From<&syn::ItemTraitAlias> for ItemTraitAlias {
    fn from(node: &syn::ItemTraitAlias) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&ItemTraitAlias> for syn::ItemTraitAlias {
    fn from(node: &ItemTraitAlias) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            trait_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            eq_token: default(),
            bounds: node.bounds.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ItemType);
impl From<&syn::ItemType> for ItemType {
    fn from(node: &syn::ItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            ty: node.ty.map_into(),
        }
    }
}
impl From<&ItemType> for syn::ItemType {
    fn from(node: &ItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            type_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            eq_token: default(),
            ty: node.ty.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::ItemUnion);
impl From<&syn::ItemUnion> for ItemUnion {
    fn from(node: &syn::ItemUnion) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            fields: node.fields.ref_into(),
        }
    }
}
impl From<&ItemUnion> for syn::ItemUnion {
    fn from(node: &ItemUnion) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            union_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            fields: node.fields.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ItemUse);
impl From<&syn::ItemUse> for ItemUse {
    fn from(node: &syn::ItemUse) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            leading_colon: node.leading_colon.is_some(),
            tree: node.tree.ref_into(),
        }
    }
}
impl From<&ItemUse> for syn::ItemUse {
    fn from(node: &ItemUse) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            vis: node.vis.ref_into(),
            use_token: default(),
            leading_colon: default_or_none(node.leading_colon),
            tree: node.tree.ref_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::Label);
impl From<&syn::Label> for Label {
    fn from(node: &syn::Label) -> Self {
        Self { name: node.name.ref_into() }
    }
}
impl From<&Label> for syn::Label {
    fn from(node: &Label) -> Self {
        Self {
            name: node.name.ref_into(),
            colon_token: default(),
        }
    }
}
syn_trait_impl!(syn::Lifetime);
impl From<&syn::Lifetime> for Lifetime {
    fn from(node: &syn::Lifetime) -> Self {
        Self {
            ident: node.ident.ref_into(),
        }
    }
}
impl From<&Lifetime> for syn::Lifetime {
    fn from(node: &Lifetime) -> Self {
        Self {
            apostrophe: proc_macro2::Span::call_site(),
            ident: node.ident.ref_into(),
        }
    }
}
syn_trait_impl!(syn::LifetimeParam);
impl From<&syn::LifetimeParam> for LifetimeParam {
    fn from(node: &syn::LifetimeParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lifetime: node.lifetime.ref_into(),
            colon_token: node.colon_token.is_some(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&LifetimeParam> for syn::LifetimeParam {
    fn from(node: &LifetimeParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            lifetime: node.lifetime.ref_into(),
            colon_token: default_or_none(node.colon_token),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::Lit);
impl From<&syn::Lit> for Lit {
    fn from(node: &syn::Lit) -> Self {
        match node {
            syn::Lit::Str(_0) => Lit::Str((*_0).ref_into()),
            syn::Lit::ByteStr(_0) => Lit::ByteStr((*_0).ref_into()),
            syn::Lit::Byte(_0) => Lit::Byte((*_0).ref_into()),
            syn::Lit::Char(_0) => Lit::Char((*_0).ref_into()),
            syn::Lit::Int(_0) => Lit::Int((*_0).ref_into()),
            syn::Lit::Float(_0) => Lit::Float((*_0).ref_into()),
            syn::Lit::Bool(_0) => Lit::Bool((*_0).ref_into()),
            syn::Lit::Verbatim(_0) => Lit::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&Lit> for syn::Lit {
    fn from(node: &Lit) -> Self {
        match node {
            Lit::Str(_0) => syn::Lit::Str((*_0).ref_into()),
            Lit::ByteStr(_0) => syn::Lit::ByteStr((*_0).ref_into()),
            Lit::Byte(_0) => syn::Lit::Byte((*_0).ref_into()),
            Lit::Char(_0) => syn::Lit::Char((*_0).ref_into()),
            Lit::Int(_0) => syn::Lit::Int((*_0).ref_into()),
            Lit::Float(_0) => syn::Lit::Float((*_0).ref_into()),
            Lit::Bool(_0) => syn::Lit::Bool((*_0).ref_into()),
            Lit::Verbatim(_0) => syn::Lit::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::LitBool);
impl From<&syn::LitBool> for LitBool {
    fn from(node: &syn::LitBool) -> Self {
        Self { value: node.value }
    }
}
impl From<&LitBool> for syn::LitBool {
    fn from(node: &LitBool) -> Self {
        Self {
            value: node.value,
            span: proc_macro2::Span::call_site(),
        }
    }
}
syn_trait_impl!(syn::Local);
impl From<&syn::Local> for Local {
    fn from(node: &syn::Local) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.ref_into(),
            init: node.init.map_into(),
        }
    }
}
impl From<&Local> for syn::Local {
    fn from(node: &Local) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            let_token: default(),
            pat: node.pat.ref_into(),
            init: node.init.map_into(),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::LocalInit);
impl From<&syn::LocalInit> for LocalInit {
    fn from(node: &syn::LocalInit) -> Self {
        Self {
            expr: node.expr.map_into(),
            diverge: node.diverge.ref_map(|(_0, _1)| (*_1).map_into()),
        }
    }
}
impl From<&LocalInit> for syn::LocalInit {
    fn from(node: &LocalInit) -> Self {
        Self {
            eq_token: default(),
            expr: node.expr.map_into(),
            diverge: node.diverge.ref_map(|_1| (default(), (*_1).map_into())),
        }
    }
}
syn_trait_impl!(syn::Macro);
impl From<&syn::Macro> for Macro {
    fn from(node: &syn::Macro) -> Self {
        Self {
            path: node.path.ref_into(),
            delimiter: node.delimiter.ref_into(),
            tokens: node.tokens.ref_into(),
        }
    }
}
impl From<&Macro> for syn::Macro {
    fn from(node: &Macro) -> Self {
        Self {
            path: node.path.ref_into(),
            bang_token: default(),
            delimiter: node.delimiter.ref_into(),
            tokens: node.tokens.ref_into(),
        }
    }
}
syn_trait_impl!(syn::MacroDelimiter);
impl From<&syn::MacroDelimiter> for MacroDelimiter {
    fn from(node: &syn::MacroDelimiter) -> Self {
        match node {
            syn::MacroDelimiter::Paren(..) => MacroDelimiter::Paren,
            syn::MacroDelimiter::Brace(..) => MacroDelimiter::Brace,
            syn::MacroDelimiter::Bracket(..) => MacroDelimiter::Bracket,
        }
    }
}
impl From<&MacroDelimiter> for syn::MacroDelimiter {
    fn from(node: &MacroDelimiter) -> Self {
        match node {
            MacroDelimiter::Paren => syn::MacroDelimiter::Paren(default()),
            MacroDelimiter::Brace => syn::MacroDelimiter::Brace(default()),
            MacroDelimiter::Bracket => syn::MacroDelimiter::Bracket(default()),
        }
    }
}
syn_trait_impl!(syn::Member);
impl From<&syn::Member> for Member {
    fn from(node: &syn::Member) -> Self {
        match node {
            syn::Member::Named(_0) => Member::Named((*_0).ref_into()),
            syn::Member::Unnamed(_0) => Member::Unnamed((*_0).ref_into()),
        }
    }
}
impl From<&Member> for syn::Member {
    fn from(node: &Member) -> Self {
        match node {
            Member::Named(_0) => syn::Member::Named((*_0).ref_into()),
            Member::Unnamed(_0) => syn::Member::Unnamed((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::Meta);
impl From<&syn::Meta> for Meta {
    fn from(node: &syn::Meta) -> Self {
        match node {
            syn::Meta::Path(_0) => Meta::Path((*_0).ref_into()),
            syn::Meta::List(_0) => Meta::List((*_0).ref_into()),
            syn::Meta::NameValue(_0) => Meta::NameValue((*_0).ref_into()),
        }
    }
}
impl From<&Meta> for syn::Meta {
    fn from(node: &Meta) -> Self {
        match node {
            Meta::Path(_0) => syn::Meta::Path((*_0).ref_into()),
            Meta::List(_0) => syn::Meta::List((*_0).ref_into()),
            Meta::NameValue(_0) => syn::Meta::NameValue((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::MetaList);
impl From<&syn::MetaList> for MetaList {
    fn from(node: &syn::MetaList) -> Self {
        Self {
            path: node.path.ref_into(),
            delimiter: node.delimiter.ref_into(),
            tokens: node.tokens.ref_into(),
        }
    }
}
impl From<&MetaList> for syn::MetaList {
    fn from(node: &MetaList) -> Self {
        Self {
            path: node.path.ref_into(),
            delimiter: node.delimiter.ref_into(),
            tokens: node.tokens.ref_into(),
        }
    }
}
syn_trait_impl!(syn::MetaNameValue);
impl From<&syn::MetaNameValue> for MetaNameValue {
    fn from(node: &syn::MetaNameValue) -> Self {
        Self {
            path: node.path.ref_into(),
            value: node.value.ref_into(),
        }
    }
}
impl From<&MetaNameValue> for syn::MetaNameValue {
    fn from(node: &MetaNameValue) -> Self {
        Self {
            path: node.path.ref_into(),
            eq_token: default(),
            value: node.value.ref_into(),
        }
    }
}
syn_trait_impl!(syn::ParenthesizedGenericArguments);
impl From<&syn::ParenthesizedGenericArguments> for ParenthesizedGenericArguments {
    fn from(node: &syn::ParenthesizedGenericArguments) -> Self {
        Self {
            inputs: node.inputs.map_into(),
            output: node.output.ref_into(),
        }
    }
}
impl From<&ParenthesizedGenericArguments> for syn::ParenthesizedGenericArguments {
    fn from(node: &ParenthesizedGenericArguments) -> Self {
        Self {
            paren_token: default(),
            inputs: node.inputs.map_into(),
            output: node.output.ref_into(),
        }
    }
}
syn_trait_impl!(syn::Pat);
impl From<&syn::Pat> for Pat {
    fn from(node: &syn::Pat) -> Self {
        match node {
            syn::Pat::Const(_0) => Pat::Const((*_0).ref_into()),
            syn::Pat::Ident(_0) => Pat::Ident((*_0).ref_into()),
            syn::Pat::Lit(_0) => Pat::Lit((*_0).ref_into()),
            syn::Pat::Macro(_0) => Pat::Macro((*_0).ref_into()),
            syn::Pat::Or(_0) => Pat::Or((*_0).ref_into()),
            syn::Pat::Paren(_0) => Pat::Paren((*_0).ref_into()),
            syn::Pat::Path(_0) => Pat::Path((*_0).ref_into()),
            syn::Pat::Range(_0) => Pat::Range((*_0).ref_into()),
            syn::Pat::Reference(_0) => Pat::Reference((*_0).ref_into()),
            syn::Pat::Rest(_0) => Pat::Rest((*_0).ref_into()),
            syn::Pat::Slice(_0) => Pat::Slice((*_0).ref_into()),
            syn::Pat::Struct(_0) => Pat::Struct((*_0).ref_into()),
            syn::Pat::Tuple(_0) => Pat::Tuple((*_0).ref_into()),
            syn::Pat::TupleStruct(_0) => Pat::TupleStruct((*_0).ref_into()),
            syn::Pat::Type(_0) => Pat::Type((*_0).ref_into()),
            syn::Pat::Verbatim(_0) => Pat::Verbatim((*_0).ref_into()),
            syn::Pat::Wild(_0) => Pat::Wild((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&Pat> for syn::Pat {
    fn from(node: &Pat) -> Self {
        match node {
            Pat::Const(_0) => syn::Pat::Const((*_0).ref_into()),
            Pat::Ident(_0) => syn::Pat::Ident((*_0).ref_into()),
            Pat::Lit(_0) => syn::Pat::Lit((*_0).ref_into()),
            Pat::Macro(_0) => syn::Pat::Macro((*_0).ref_into()),
            Pat::Or(_0) => syn::Pat::Or((*_0).ref_into()),
            Pat::Paren(_0) => syn::Pat::Paren((*_0).ref_into()),
            Pat::Path(_0) => syn::Pat::Path((*_0).ref_into()),
            Pat::Range(_0) => syn::Pat::Range((*_0).ref_into()),
            Pat::Reference(_0) => syn::Pat::Reference((*_0).ref_into()),
            Pat::Rest(_0) => syn::Pat::Rest((*_0).ref_into()),
            Pat::Slice(_0) => syn::Pat::Slice((*_0).ref_into()),
            Pat::Struct(_0) => syn::Pat::Struct((*_0).ref_into()),
            Pat::Tuple(_0) => syn::Pat::Tuple((*_0).ref_into()),
            Pat::TupleStruct(_0) => syn::Pat::TupleStruct((*_0).ref_into()),
            Pat::Type(_0) => syn::Pat::Type((*_0).ref_into()),
            Pat::Verbatim(_0) => syn::Pat::Verbatim((*_0).ref_into()),
            Pat::Wild(_0) => syn::Pat::Wild((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::PatIdent);
impl From<&syn::PatIdent> for PatIdent {
    fn from(node: &syn::PatIdent) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            by_ref: node.by_ref.is_some(),
            mutability: node.mutability.is_some(),
            ident: node.ident.ref_into(),
            subpat: node.subpat.ref_map(|(_0, _1)| (*_1).map_into()),
        }
    }
}
impl From<&PatIdent> for syn::PatIdent {
    fn from(node: &PatIdent) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            by_ref: default_or_none(node.by_ref),
            mutability: default_or_none(node.mutability),
            ident: node.ident.ref_into(),
            subpat: node.subpat.ref_map(|_1| (default(), (*_1).map_into())),
        }
    }
}
syn_trait_impl!(syn::PatOr);
impl From<&syn::PatOr> for PatOr {
    fn from(node: &syn::PatOr) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            leading_vert: node.leading_vert.is_some(),
            cases: node.cases.map_into(),
        }
    }
}
impl From<&PatOr> for syn::PatOr {
    fn from(node: &PatOr) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            leading_vert: default_or_none(node.leading_vert),
            cases: node.cases.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatParen);
impl From<&syn::PatParen> for PatParen {
    fn from(node: &syn::PatParen) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.map_into(),
        }
    }
}
impl From<&PatParen> for syn::PatParen {
    fn from(node: &PatParen) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            paren_token: default(),
            pat: node.pat.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatReference);
impl From<&syn::PatReference> for PatReference {
    fn from(node: &syn::PatReference) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mutability: node.mutability.is_some(),
            pat: node.pat.map_into(),
        }
    }
}
impl From<&PatReference> for syn::PatReference {
    fn from(node: &PatReference) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            and_token: default(),
            mutability: default_or_none(node.mutability),
            pat: node.pat.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatRest);
impl From<&syn::PatRest> for PatRest {
    fn from(node: &syn::PatRest) -> Self {
        Self {
            attrs: node.attrs.map_into(),
        }
    }
}
impl From<&PatRest> for syn::PatRest {
    fn from(node: &PatRest) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            dot2_token: default(),
        }
    }
}
syn_trait_impl!(syn::PatSlice);
impl From<&syn::PatSlice> for PatSlice {
    fn from(node: &syn::PatSlice) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            elems: node.elems.map_into(),
        }
    }
}
impl From<&PatSlice> for syn::PatSlice {
    fn from(node: &PatSlice) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            bracket_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatStruct);
impl From<&syn::PatStruct> for PatStruct {
    fn from(node: &syn::PatStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            fields: node.fields.map_into(),
            rest: node.rest.map_into(),
        }
    }
}
impl From<&PatStruct> for syn::PatStruct {
    fn from(node: &PatStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            brace_token: default(),
            fields: node.fields.map_into(),
            rest: node.rest.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatTuple);
impl From<&syn::PatTuple> for PatTuple {
    fn from(node: &syn::PatTuple) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            elems: node.elems.map_into(),
        }
    }
}
impl From<&PatTuple> for syn::PatTuple {
    fn from(node: &PatTuple) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            paren_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatTupleStruct);
impl From<&syn::PatTupleStruct> for PatTupleStruct {
    fn from(node: &syn::PatTupleStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            elems: node.elems.map_into(),
        }
    }
}
impl From<&PatTupleStruct> for syn::PatTupleStruct {
    fn from(node: &PatTupleStruct) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
            paren_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatType);
impl From<&syn::PatType> for PatType {
    fn from(node: &syn::PatType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.map_into(),
            ty: node.ty.map_into(),
        }
    }
}
impl From<&PatType> for syn::PatType {
    fn from(node: &PatType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.map_into(),
            colon_token: default(),
            ty: node.ty.map_into(),
        }
    }
}
syn_trait_impl!(syn::PatWild);
impl From<&syn::PatWild> for PatWild {
    fn from(node: &syn::PatWild) -> Self {
        Self {
            attrs: node.attrs.map_into(),
        }
    }
}
impl From<&PatWild> for syn::PatWild {
    fn from(node: &PatWild) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            underscore_token: default(),
        }
    }
}
syn_trait_impl!(syn::Path);
impl From<&syn::Path> for Path {
    fn from(node: &syn::Path) -> Self {
        Self {
            leading_colon: node.leading_colon.is_some(),
            segments: node.segments.map_into(),
        }
    }
}
impl From<&Path> for syn::Path {
    fn from(node: &Path) -> Self {
        Self {
            leading_colon: default_or_none(node.leading_colon),
            segments: node.segments.map_into(),
        }
    }
}
syn_trait_impl!(syn::PathArguments);
impl From<&syn::PathArguments> for PathArguments {
    fn from(node: &syn::PathArguments) -> Self {
        match node {
            syn::PathArguments::None => PathArguments::None,
            syn::PathArguments::AngleBracketed(_0) => {
                PathArguments::AngleBracketed((*_0).ref_into())
            }
            syn::PathArguments::Parenthesized(_0) => {
                PathArguments::Parenthesized((*_0).ref_into())
            }
        }
    }
}
impl From<&PathArguments> for syn::PathArguments {
    fn from(node: &PathArguments) -> Self {
        match node {
            PathArguments::None => syn::PathArguments::None,
            PathArguments::AngleBracketed(_0) => {
                syn::PathArguments::AngleBracketed((*_0).ref_into())
            }
            PathArguments::Parenthesized(_0) => {
                syn::PathArguments::Parenthesized((*_0).ref_into())
            }
        }
    }
}
syn_trait_impl!(syn::PathSegment);
impl From<&syn::PathSegment> for PathSegment {
    fn from(node: &syn::PathSegment) -> Self {
        Self {
            ident: node.ident.ref_into(),
            arguments: node.arguments.ref_into(),
        }
    }
}
impl From<&PathSegment> for syn::PathSegment {
    fn from(node: &PathSegment) -> Self {
        Self {
            ident: node.ident.ref_into(),
            arguments: node.arguments.ref_into(),
        }
    }
}
syn_trait_impl!(syn::PredicateLifetime);
impl From<&syn::PredicateLifetime> for PredicateLifetime {
    fn from(node: &syn::PredicateLifetime) -> Self {
        Self {
            lifetime: node.lifetime.ref_into(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&PredicateLifetime> for syn::PredicateLifetime {
    fn from(node: &PredicateLifetime) -> Self {
        Self {
            lifetime: node.lifetime.ref_into(),
            colon_token: default(),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::PredicateType);
impl From<&syn::PredicateType> for PredicateType {
    fn from(node: &syn::PredicateType) -> Self {
        Self {
            lifetimes: node.lifetimes.map_into(),
            bounded_ty: node.bounded_ty.ref_into(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&PredicateType> for syn::PredicateType {
    fn from(node: &PredicateType) -> Self {
        Self {
            lifetimes: node.lifetimes.map_into(),
            bounded_ty: node.bounded_ty.ref_into(),
            colon_token: default(),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::QSelf);
impl From<&syn::QSelf> for QSelf {
    fn from(node: &syn::QSelf) -> Self {
        Self {
            ty: node.ty.map_into(),
            position: node.position,
            as_token: node.as_token.is_some(),
        }
    }
}
impl From<&QSelf> for syn::QSelf {
    fn from(node: &QSelf) -> Self {
        Self {
            lt_token: default(),
            ty: node.ty.map_into(),
            position: node.position,
            as_token: default_or_none(node.as_token),
            gt_token: default(),
        }
    }
}
syn_trait_impl!(syn::RangeLimits);
impl From<&syn::RangeLimits> for RangeLimits {
    fn from(node: &syn::RangeLimits) -> Self {
        match node {
            syn::RangeLimits::HalfOpen(..) => RangeLimits::HalfOpen,
            syn::RangeLimits::Closed(..) => RangeLimits::Closed,
        }
    }
}
impl From<&RangeLimits> for syn::RangeLimits {
    fn from(node: &RangeLimits) -> Self {
        match node {
            RangeLimits::HalfOpen => syn::RangeLimits::HalfOpen(default()),
            RangeLimits::Closed => syn::RangeLimits::Closed(default()),
        }
    }
}
syn_trait_impl!(syn::Signature);
impl From<&syn::Signature> for Signature {
    fn from(node: &syn::Signature) -> Self {
        Self {
            constness: node.constness.is_some(),
            asyncness: node.asyncness.is_some(),
            unsafety: node.unsafety.is_some(),
            abi: node.abi.map_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            inputs: node.inputs.map_into(),
            variadic: node.variadic.map_into(),
            output: node.output.ref_into(),
        }
    }
}
impl From<&Signature> for syn::Signature {
    fn from(node: &Signature) -> Self {
        Self {
            constness: default_or_none(node.constness),
            asyncness: default_or_none(node.asyncness),
            unsafety: default_or_none(node.unsafety),
            abi: node.abi.map_into(),
            fn_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            paren_token: default(),
            inputs: node.inputs.map_into(),
            variadic: node.variadic.map_into(),
            output: node.output.ref_into(),
        }
    }
}
syn_trait_impl!(syn::StaticMutability);
impl From<&syn::StaticMutability> for StaticMutability {
    fn from(node: &syn::StaticMutability) -> Self {
        match node {
            syn::StaticMutability::Mut(..) => StaticMutability::Mut,
            syn::StaticMutability::None => StaticMutability::None,
            _ => unreachable!(),
        }
    }
}
impl From<&StaticMutability> for syn::StaticMutability {
    fn from(node: &StaticMutability) -> Self {
        match node {
            StaticMutability::Mut => syn::StaticMutability::Mut(default()),
            StaticMutability::None => syn::StaticMutability::None,
        }
    }
}
syn_trait_impl!(syn::Stmt);
impl From<&syn::Stmt> for Stmt {
    fn from(node: &syn::Stmt) -> Self {
        match node {
            syn::Stmt::Local(_0) => Stmt::Local((*_0).ref_into()),
            syn::Stmt::Item(_0) => Stmt::Item((*_0).ref_into()),
            syn::Stmt::Expr(_0, _1) => Stmt::Expr((*_0).ref_into(), (*_1).is_some()),
            syn::Stmt::Macro(_0) => Stmt::Macro((*_0).ref_into()),
        }
    }
}
impl From<&Stmt> for syn::Stmt {
    fn from(node: &Stmt) -> Self {
        match node {
            Stmt::Local(_0) => syn::Stmt::Local((*_0).ref_into()),
            Stmt::Item(_0) => syn::Stmt::Item((*_0).ref_into()),
            Stmt::Expr(_0, _1) => {
                syn::Stmt::Expr((*_0).ref_into(), default_or_none((*_1)))
            }
            Stmt::Macro(_0) => syn::Stmt::Macro((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::StmtMacro);
impl From<&syn::StmtMacro> for StmtMacro {
    fn from(node: &syn::StmtMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: node.semi_token.is_some(),
        }
    }
}
impl From<&StmtMacro> for syn::StmtMacro {
    fn from(node: &StmtMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: default_or_none(node.semi_token),
        }
    }
}
syn_trait_impl!(syn::TraitBound);
impl From<&syn::TraitBound> for TraitBound {
    fn from(node: &syn::TraitBound) -> Self {
        Self {
            paren_token: node.paren_token.is_some(),
            modifier: node.modifier.ref_into(),
            lifetimes: node.lifetimes.map_into(),
            path: node.path.ref_into(),
        }
    }
}
impl From<&TraitBound> for syn::TraitBound {
    fn from(node: &TraitBound) -> Self {
        Self {
            paren_token: default_or_none(node.paren_token),
            modifier: node.modifier.ref_into(),
            lifetimes: node.lifetimes.map_into(),
            path: node.path.ref_into(),
        }
    }
}
syn_trait_impl!(syn::TraitBoundModifier);
impl From<&syn::TraitBoundModifier> for TraitBoundModifier {
    fn from(node: &syn::TraitBoundModifier) -> Self {
        match node {
            syn::TraitBoundModifier::None => TraitBoundModifier::None,
            syn::TraitBoundModifier::Maybe(..) => TraitBoundModifier::Maybe,
        }
    }
}
impl From<&TraitBoundModifier> for syn::TraitBoundModifier {
    fn from(node: &TraitBoundModifier) -> Self {
        match node {
            TraitBoundModifier::None => syn::TraitBoundModifier::None,
            TraitBoundModifier::Maybe => syn::TraitBoundModifier::Maybe(default()),
        }
    }
}
syn_trait_impl!(syn::TraitItem);
impl From<&syn::TraitItem> for TraitItem {
    fn from(node: &syn::TraitItem) -> Self {
        match node {
            syn::TraitItem::Const(_0) => TraitItem::Const((*_0).ref_into()),
            syn::TraitItem::Fn(_0) => TraitItem::Fn((*_0).ref_into()),
            syn::TraitItem::Type(_0) => TraitItem::Type((*_0).ref_into()),
            syn::TraitItem::Macro(_0) => TraitItem::Macro((*_0).ref_into()),
            syn::TraitItem::Verbatim(_0) => TraitItem::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&TraitItem> for syn::TraitItem {
    fn from(node: &TraitItem) -> Self {
        match node {
            TraitItem::Const(_0) => syn::TraitItem::Const((*_0).ref_into()),
            TraitItem::Fn(_0) => syn::TraitItem::Fn((*_0).ref_into()),
            TraitItem::Type(_0) => syn::TraitItem::Type((*_0).ref_into()),
            TraitItem::Macro(_0) => syn::TraitItem::Macro((*_0).ref_into()),
            TraitItem::Verbatim(_0) => syn::TraitItem::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::TraitItemConst);
impl From<&syn::TraitItemConst> for TraitItemConst {
    fn from(node: &syn::TraitItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            ty: node.ty.ref_into(),
            default: node.default.ref_map(|(_0, _1)| (*_1).ref_into()),
        }
    }
}
impl From<&TraitItemConst> for syn::TraitItemConst {
    fn from(node: &TraitItemConst) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            const_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: default(),
            ty: node.ty.ref_into(),
            default: node.default.ref_map(|_1| (default(), (*_1).ref_into())),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::TraitItemMacro);
impl From<&syn::TraitItemMacro> for TraitItemMacro {
    fn from(node: &syn::TraitItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: node.semi_token.is_some(),
        }
    }
}
impl From<&TraitItemMacro> for syn::TraitItemMacro {
    fn from(node: &TraitItemMacro) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            mac: node.mac.ref_into(),
            semi_token: default_or_none(node.semi_token),
        }
    }
}
syn_trait_impl!(syn::TraitItemType);
impl From<&syn::TraitItemType> for TraitItemType {
    fn from(node: &syn::TraitItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: node.colon_token.is_some(),
            bounds: node.bounds.map_into(),
            default: node.default.ref_map(|(_0, _1)| (*_1).ref_into()),
        }
    }
}
impl From<&TraitItemType> for syn::TraitItemType {
    fn from(node: &TraitItemType) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            type_token: default(),
            ident: node.ident.ref_into(),
            generics: node.generics.ref_into(),
            colon_token: default_or_none(node.colon_token),
            bounds: node.bounds.map_into(),
            default: node.default.ref_map(|_1| (default(), (*_1).ref_into())),
            semi_token: default(),
        }
    }
}
syn_trait_impl!(syn::Type);
impl From<&syn::Type> for Type {
    fn from(node: &syn::Type) -> Self {
        match node {
            syn::Type::Array(_0) => Type::Array((*_0).ref_into()),
            syn::Type::BareFn(_0) => Type::BareFn((*_0).ref_into()),
            syn::Type::Group(_0) => Type::Group((*_0).ref_into()),
            syn::Type::ImplTrait(_0) => Type::ImplTrait((*_0).ref_into()),
            syn::Type::Infer(..) => Type::Infer,
            syn::Type::Macro(_0) => Type::Macro((*_0).ref_into()),
            syn::Type::Never(..) => Type::Never,
            syn::Type::Paren(_0) => Type::Paren((*_0).ref_into()),
            syn::Type::Path(_0) => Type::Path((*_0).ref_into()),
            syn::Type::Ptr(_0) => Type::Ptr((*_0).ref_into()),
            syn::Type::Reference(_0) => Type::Reference((*_0).ref_into()),
            syn::Type::Slice(_0) => Type::Slice((*_0).ref_into()),
            syn::Type::TraitObject(_0) => Type::TraitObject((*_0).ref_into()),
            syn::Type::Tuple(_0) => Type::Tuple((*_0).ref_into()),
            syn::Type::Verbatim(_0) => Type::Verbatim((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&Type> for syn::Type {
    fn from(node: &Type) -> Self {
        match node {
            Type::Array(_0) => syn::Type::Array((*_0).ref_into()),
            Type::BareFn(_0) => syn::Type::BareFn((*_0).ref_into()),
            Type::Group(_0) => syn::Type::Group((*_0).ref_into()),
            Type::ImplTrait(_0) => syn::Type::ImplTrait((*_0).ref_into()),
            Type::Infer => {
                syn::Type::Infer(syn::TypeInfer {
                    underscore_token: default(),
                })
            }
            Type::Macro(_0) => syn::Type::Macro((*_0).ref_into()),
            Type::Never => {
                syn::Type::Never(syn::TypeNever {
                    bang_token: default(),
                })
            }
            Type::Paren(_0) => syn::Type::Paren((*_0).ref_into()),
            Type::Path(_0) => syn::Type::Path((*_0).ref_into()),
            Type::Ptr(_0) => syn::Type::Ptr((*_0).ref_into()),
            Type::Reference(_0) => syn::Type::Reference((*_0).ref_into()),
            Type::Slice(_0) => syn::Type::Slice((*_0).ref_into()),
            Type::TraitObject(_0) => syn::Type::TraitObject((*_0).ref_into()),
            Type::Tuple(_0) => syn::Type::Tuple((*_0).ref_into()),
            Type::Verbatim(_0) => syn::Type::Verbatim((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::TypeArray);
impl From<&syn::TypeArray> for TypeArray {
    fn from(node: &syn::TypeArray) -> Self {
        Self {
            elem: node.elem.map_into(),
            len: node.len.ref_into(),
        }
    }
}
impl From<&TypeArray> for syn::TypeArray {
    fn from(node: &TypeArray) -> Self {
        Self {
            bracket_token: default(),
            elem: node.elem.map_into(),
            semi_token: default(),
            len: node.len.ref_into(),
        }
    }
}
syn_trait_impl!(syn::TypeBareFn);
impl From<&syn::TypeBareFn> for TypeBareFn {
    fn from(node: &syn::TypeBareFn) -> Self {
        Self {
            lifetimes: node.lifetimes.map_into(),
            unsafety: node.unsafety.is_some(),
            abi: node.abi.map_into(),
            inputs: node.inputs.map_into(),
            variadic: node.variadic.map_into(),
            output: node.output.ref_into(),
        }
    }
}
impl From<&TypeBareFn> for syn::TypeBareFn {
    fn from(node: &TypeBareFn) -> Self {
        Self {
            lifetimes: node.lifetimes.map_into(),
            unsafety: default_or_none(node.unsafety),
            abi: node.abi.map_into(),
            fn_token: default(),
            paren_token: default(),
            inputs: node.inputs.map_into(),
            variadic: node.variadic.map_into(),
            output: node.output.ref_into(),
        }
    }
}
syn_trait_impl!(syn::TypeGroup);
impl From<&syn::TypeGroup> for TypeGroup {
    fn from(node: &syn::TypeGroup) -> Self {
        Self { elem: node.elem.map_into() }
    }
}
impl From<&TypeGroup> for syn::TypeGroup {
    fn from(node: &TypeGroup) -> Self {
        Self {
            group_token: default(),
            elem: node.elem.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeImplTrait);
impl From<&syn::TypeImplTrait> for TypeImplTrait {
    fn from(node: &syn::TypeImplTrait) -> Self {
        Self {
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&TypeImplTrait> for syn::TypeImplTrait {
    fn from(node: &TypeImplTrait) -> Self {
        Self {
            impl_token: default(),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeMacro);
impl From<&syn::TypeMacro> for TypeMacro {
    fn from(node: &syn::TypeMacro) -> Self {
        Self { mac: node.mac.ref_into() }
    }
}
impl From<&TypeMacro> for syn::TypeMacro {
    fn from(node: &TypeMacro) -> Self {
        Self { mac: node.mac.ref_into() }
    }
}
syn_trait_impl!(syn::TypeParam);
impl From<&syn::TypeParam> for TypeParam {
    fn from(node: &syn::TypeParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            colon_token: node.colon_token.is_some(),
            bounds: node.bounds.map_into(),
            eq_token: node.eq_token.is_some(),
            default: node.default.map_into(),
        }
    }
}
impl From<&TypeParam> for syn::TypeParam {
    fn from(node: &TypeParam) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            colon_token: default_or_none(node.colon_token),
            bounds: node.bounds.map_into(),
            eq_token: default_or_none(node.eq_token),
            default: node.default.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeParamBound);
impl From<&syn::TypeParamBound> for TypeParamBound {
    fn from(node: &syn::TypeParamBound) -> Self {
        match node {
            syn::TypeParamBound::Trait(_0) => TypeParamBound::Trait((*_0).ref_into()),
            syn::TypeParamBound::Lifetime(_0) => {
                TypeParamBound::Lifetime((*_0).ref_into())
            }
            syn::TypeParamBound::Verbatim(_0) => {
                TypeParamBound::Verbatim((*_0).ref_into())
            }
            _ => unreachable!(),
        }
    }
}
impl From<&TypeParamBound> for syn::TypeParamBound {
    fn from(node: &TypeParamBound) -> Self {
        match node {
            TypeParamBound::Trait(_0) => syn::TypeParamBound::Trait((*_0).ref_into()),
            TypeParamBound::Lifetime(_0) => {
                syn::TypeParamBound::Lifetime((*_0).ref_into())
            }
            TypeParamBound::Verbatim(_0) => {
                syn::TypeParamBound::Verbatim((*_0).ref_into())
            }
        }
    }
}
syn_trait_impl!(syn::TypeParen);
impl From<&syn::TypeParen> for TypeParen {
    fn from(node: &syn::TypeParen) -> Self {
        Self { elem: node.elem.map_into() }
    }
}
impl From<&TypeParen> for syn::TypeParen {
    fn from(node: &TypeParen) -> Self {
        Self {
            paren_token: default(),
            elem: node.elem.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypePath);
impl From<&syn::TypePath> for TypePath {
    fn from(node: &syn::TypePath) -> Self {
        Self {
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
        }
    }
}
impl From<&TypePath> for syn::TypePath {
    fn from(node: &TypePath) -> Self {
        Self {
            qself: node.qself.map_into(),
            path: node.path.ref_into(),
        }
    }
}
syn_trait_impl!(syn::TypePtr);
impl From<&syn::TypePtr> for TypePtr {
    fn from(node: &syn::TypePtr) -> Self {
        Self {
            const_token: node.const_token.is_some(),
            mutability: node.mutability.is_some(),
            elem: node.elem.map_into(),
        }
    }
}
impl From<&TypePtr> for syn::TypePtr {
    fn from(node: &TypePtr) -> Self {
        Self {
            star_token: default(),
            const_token: default_or_none(node.const_token),
            mutability: default_or_none(node.mutability),
            elem: node.elem.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeReference);
impl From<&syn::TypeReference> for TypeReference {
    fn from(node: &syn::TypeReference) -> Self {
        Self {
            lifetime: node.lifetime.map_into(),
            mutability: node.mutability.is_some(),
            elem: node.elem.map_into(),
        }
    }
}
impl From<&TypeReference> for syn::TypeReference {
    fn from(node: &TypeReference) -> Self {
        Self {
            and_token: default(),
            lifetime: node.lifetime.map_into(),
            mutability: default_or_none(node.mutability),
            elem: node.elem.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeSlice);
impl From<&syn::TypeSlice> for TypeSlice {
    fn from(node: &syn::TypeSlice) -> Self {
        Self { elem: node.elem.map_into() }
    }
}
impl From<&TypeSlice> for syn::TypeSlice {
    fn from(node: &TypeSlice) -> Self {
        Self {
            bracket_token: default(),
            elem: node.elem.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeTraitObject);
impl From<&syn::TypeTraitObject> for TypeTraitObject {
    fn from(node: &syn::TypeTraitObject) -> Self {
        Self {
            dyn_token: node.dyn_token.is_some(),
            bounds: node.bounds.map_into(),
        }
    }
}
impl From<&TypeTraitObject> for syn::TypeTraitObject {
    fn from(node: &TypeTraitObject) -> Self {
        Self {
            dyn_token: default_or_none(node.dyn_token),
            bounds: node.bounds.map_into(),
        }
    }
}
syn_trait_impl!(syn::TypeTuple);
impl From<&syn::TypeTuple> for TypeTuple {
    fn from(node: &syn::TypeTuple) -> Self {
        Self {
            elems: node.elems.map_into(),
        }
    }
}
impl From<&TypeTuple> for syn::TypeTuple {
    fn from(node: &TypeTuple) -> Self {
        Self {
            paren_token: default(),
            elems: node.elems.map_into(),
        }
    }
}
syn_trait_impl!(syn::UnOp);
impl From<&syn::UnOp> for UnOp {
    fn from(node: &syn::UnOp) -> Self {
        match node {
            syn::UnOp::Deref(..) => UnOp::Deref,
            syn::UnOp::Not(..) => UnOp::Not,
            syn::UnOp::Neg(..) => UnOp::Neg,
            _ => unreachable!(),
        }
    }
}
impl From<&UnOp> for syn::UnOp {
    fn from(node: &UnOp) -> Self {
        match node {
            UnOp::Deref => syn::UnOp::Deref(default()),
            UnOp::Not => syn::UnOp::Not(default()),
            UnOp::Neg => syn::UnOp::Neg(default()),
        }
    }
}
syn_trait_impl!(syn::UseGroup);
impl From<&syn::UseGroup> for UseGroup {
    fn from(node: &syn::UseGroup) -> Self {
        Self {
            items: node.items.map_into(),
        }
    }
}
impl From<&UseGroup> for syn::UseGroup {
    fn from(node: &UseGroup) -> Self {
        Self {
            brace_token: default(),
            items: node.items.map_into(),
        }
    }
}
syn_trait_impl!(syn::UseName);
impl From<&syn::UseName> for UseName {
    fn from(node: &syn::UseName) -> Self {
        Self {
            ident: node.ident.ref_into(),
        }
    }
}
impl From<&UseName> for syn::UseName {
    fn from(node: &UseName) -> Self {
        Self {
            ident: node.ident.ref_into(),
        }
    }
}
syn_trait_impl!(syn::UsePath);
impl From<&syn::UsePath> for UsePath {
    fn from(node: &syn::UsePath) -> Self {
        Self {
            ident: node.ident.ref_into(),
            tree: node.tree.map_into(),
        }
    }
}
impl From<&UsePath> for syn::UsePath {
    fn from(node: &UsePath) -> Self {
        Self {
            ident: node.ident.ref_into(),
            colon2_token: default(),
            tree: node.tree.map_into(),
        }
    }
}
syn_trait_impl!(syn::UseRename);
impl From<&syn::UseRename> for UseRename {
    fn from(node: &syn::UseRename) -> Self {
        Self {
            ident: node.ident.ref_into(),
            rename: node.rename.ref_into(),
        }
    }
}
impl From<&UseRename> for syn::UseRename {
    fn from(node: &UseRename) -> Self {
        Self {
            ident: node.ident.ref_into(),
            as_token: default(),
            rename: node.rename.ref_into(),
        }
    }
}
syn_trait_impl!(syn::UseTree);
impl From<&syn::UseTree> for UseTree {
    fn from(node: &syn::UseTree) -> Self {
        match node {
            syn::UseTree::Path(_0) => UseTree::Path((*_0).ref_into()),
            syn::UseTree::Name(_0) => UseTree::Name((*_0).ref_into()),
            syn::UseTree::Rename(_0) => UseTree::Rename((*_0).ref_into()),
            syn::UseTree::Glob(..) => UseTree::Glob,
            syn::UseTree::Group(_0) => UseTree::Group((*_0).ref_into()),
        }
    }
}
impl From<&UseTree> for syn::UseTree {
    fn from(node: &UseTree) -> Self {
        match node {
            UseTree::Path(_0) => syn::UseTree::Path((*_0).ref_into()),
            UseTree::Name(_0) => syn::UseTree::Name((*_0).ref_into()),
            UseTree::Rename(_0) => syn::UseTree::Rename((*_0).ref_into()),
            UseTree::Glob => {
                syn::UseTree::Glob(syn::UseGlob {
                    star_token: default(),
                })
            }
            UseTree::Group(_0) => syn::UseTree::Group((*_0).ref_into()),
        }
    }
}
syn_trait_impl!(syn::Variadic);
impl From<&syn::Variadic> for Variadic {
    fn from(node: &syn::Variadic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.ref_map(|(_0, _1)| (*_0).map_into()),
            comma: node.comma.is_some(),
        }
    }
}
impl From<&Variadic> for syn::Variadic {
    fn from(node: &Variadic) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            pat: node.pat.ref_map(|_0| ((*_0).map_into(), default())),
            dots: default(),
            comma: default_or_none(node.comma),
        }
    }
}
syn_trait_impl!(syn::Variant);
impl From<&syn::Variant> for Variant {
    fn from(node: &syn::Variant) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            fields: node.fields.ref_into(),
            discriminant: node.discriminant.ref_map(|(_0, _1)| (*_1).ref_into()),
        }
    }
}
impl From<&Variant> for syn::Variant {
    fn from(node: &Variant) -> Self {
        Self {
            attrs: node.attrs.map_into(),
            ident: node.ident.ref_into(),
            fields: node.fields.ref_into(),
            discriminant: node.discriminant.ref_map(|_1| (default(), (*_1).ref_into())),
        }
    }
}
syn_trait_impl!(syn::VisRestricted);
impl From<&syn::VisRestricted> for VisRestricted {
    fn from(node: &syn::VisRestricted) -> Self {
        Self {
            in_token: node.in_token.is_some(),
            path: node.path.map_into(),
        }
    }
}
impl From<&VisRestricted> for syn::VisRestricted {
    fn from(node: &VisRestricted) -> Self {
        Self {
            pub_token: default(),
            paren_token: default(),
            in_token: default_or_none(node.in_token),
            path: node.path.map_into(),
        }
    }
}
syn_trait_impl!(syn::Visibility);
impl From<&syn::Visibility> for Visibility {
    fn from(node: &syn::Visibility) -> Self {
        match node {
            syn::Visibility::Public(..) => Visibility::Public,
            syn::Visibility::Restricted(_0) => Visibility::Restricted((*_0).ref_into()),
            syn::Visibility::Inherited => Visibility::Inherited,
        }
    }
}
impl From<&Visibility> for syn::Visibility {
    fn from(node: &Visibility) -> Self {
        match node {
            Visibility::Public => syn::Visibility::Public(default()),
            Visibility::Restricted(_0) => syn::Visibility::Restricted((*_0).ref_into()),
            Visibility::Inherited => syn::Visibility::Inherited,
        }
    }
}
syn_trait_impl!(syn::WhereClause);
impl From<&syn::WhereClause> for WhereClause {
    fn from(node: &syn::WhereClause) -> Self {
        Self {
            predicates: node.predicates.map_into(),
        }
    }
}
impl From<&WhereClause> for syn::WhereClause {
    fn from(node: &WhereClause) -> Self {
        Self {
            where_token: default(),
            predicates: node.predicates.map_into(),
        }
    }
}
syn_trait_impl!(syn::WherePredicate);
impl From<&syn::WherePredicate> for WherePredicate {
    fn from(node: &syn::WherePredicate) -> Self {
        match node {
            syn::WherePredicate::Lifetime(_0) => {
                WherePredicate::Lifetime((*_0).ref_into())
            }
            syn::WherePredicate::Type(_0) => WherePredicate::Type((*_0).ref_into()),
            _ => unreachable!(),
        }
    }
}
impl From<&WherePredicate> for syn::WherePredicate {
    fn from(node: &WherePredicate) -> Self {
        match node {
            WherePredicate::Lifetime(_0) => {
                syn::WherePredicate::Lifetime((*_0).ref_into())
            }
            WherePredicate::Type(_0) => syn::WherePredicate::Type((*_0).ref_into()),
        }
    }
}
